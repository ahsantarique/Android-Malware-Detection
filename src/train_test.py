import os
import math
import numpy as np
from sklearn.svm import SVR
from sklearn.model_selection import cross_val_score
import gc
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, make_scorer
from scipy.stats import pearsonr
from sklearn.neural_network import MLPRegressor
from sklearn.naive_bayes import GaussianNB


def p(y_pred,y_true):
    return pearsonr(y_pred,y_true)[0]


def neuralNet():
	return MLPRegressor(hidden_layer_sizes=(50,100,50), activation='relu', 
                    alpha=0.05, batch_size=128, early_stopping=True, 
                    learning_rate_init=0.01, solver='adam', learning_rate='adaptive', nesterovs_momentum=True, 
                    max_iter=100, tol=1e-8, verbose=False, validation_fraction=0.1)

def svr():
	return SVR(C=0.1, epsilon=0.01)



def splitMetrics(clf, X, y):
	X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.9)

	gc.collect()



	clf.fit(X_train, y_train)
	y_test_pred = clf.predict(X_test)
	y_train_pred = clf.predict(X_train)

	gc.collect()

	print(p(y_train, y_train_pred))
	print(mean_squared_error(y_train, y_train_pred))
	print(p(y_test, y_test_pred))



def crossValidate(clf, X, y):
	# score = make_scorer(p, greater_is_better=True)
	scores = cross_val_score(clf, X, y, cv=10, scoring = 'f1')
	# scores = cross_val_score(clf, X, y, cv=10, scoring='neg_mean_squared_error')
	print("*******************")
	print("F1 score of 10 fold CV:", scores)



GOOD_DATA = 'data/good.dat'
BAD_DAT = 'data/bad.dat'

def loadDataSet():
	X0 = np.loadtxt(GOOD_DATA, dtype='float')

	y0 = np.array([0 for i in range(len(X0))])

	X1 = np.loadtxt(BAD_DAT, dtype='float')

	y1 = np.array([1 for i in range(len(X1))])
	
	X = np.append(X0, X1, axis=0)

	y = np.append(y0, y1)
	
	return X, y



def main():
	X, y = loadDataSet()

	# clf = svr() # or 
	clf = GaussianNB()

	# splitMetrics(clf, X, y) # or 
	crossValidate(clf, X, y)

	# print(len(y))

	# c = 0.1
	# eps = 0.01
	# # for c,eps in (range(0.1,.5,4)*range(0.01,0.01,3)):
	# clf = SVR(C=c, epsilon=eps)
	# # clf.fit(X[:20], y[:20])

if __name__ == "__main__":
	main()